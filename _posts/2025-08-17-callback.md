---
layout: post
title: How Callback Works
tags: [JS]
---

Understanding Callback Functions in JavaScript (Made Simple)
============================================================

When people first hear about **callback functions**, they often get confused. The term sounds fancy, but the concept is actually straightforward once you break it down. Letâ€™s go step by step.

* * *

1. What Is a Callback Function?

-------------------------------

A **callback function** is simply a function that you **pass as an argument** to another function. The receiving function can then **decide when to call (or â€œcall backâ€) that function**.

ðŸ‘‰ Think of it like giving someone your phone number. Theyâ€™re not calling you right away. Instead, youâ€™re saying:  
_â€œHereâ€™s my number. Call me back later when you have news.â€_

Thatâ€™s exactly what a callback is in programming:

* You pass a function (your phone number).

* The other function saves it.

* It â€œcalls backâ€ that function at the right time.

* * *

2. Passing Functions as Arguments

---------------------------------

In JavaScript, functions are **first-class citizens**. This means you can treat them like any other variable â€” you can assign them to variables, pass them around, and use them as arguments.

```
function greet(name) {
  console.log("Hello, " + name);
}

function processUserInput(callback) {
  const name = "Alice";
  callback(name);  // call the function passed in
}

processUserInput(greet);
// Output: Hello, Alice

```

* Here, `greet` is not executed immediately when we pass it to `processUserInput`.

* Instead, its **reference** is passed (basically, the memory address where the function lives).

* Later, inside `processUserInput`, the function gets invoked with `callback(name)`.

* * *

3. Regular Functions vs Callback Functions

------------------------------------------

You can think about it like this:

* **Regular function** â†’ Takes data as input and always applies the _same method_ to process it.

* **Callback function** â†’ Lets you change the _method itself_. Youâ€™re basically passing an _algorithm_ (a function) into another function, so the same data can be processed in different ways.

Example:

```
function processNumbers(numbers, callback) {
  return numbers.map(callback);
}

const numbers = [1, 2, 3];

// Double each number
console.log(processNumbers(numbers, num => num * 2));
// [2, 4, 6]

// Square each number
console.log(processNumbers(numbers, num => num * num));
// [1, 4, 9]

```

Here, the same data (`numbers`) is processed differently depending on which callback you provide.

* * *

4. Why Do We Need Callbacks?

----------------------------

The **real power** of callbacks comes with **asynchronous operations**.

JavaScript is single-threaded â€” it canâ€™t do everything at once. But things like:

* Reading a file,

* Making a network request,

* Querying a database,

all take time. If the program paused and waited for these to finish, everything would freeze!

Instead, JavaScript says:

* â€œIâ€™ll start this operation.â€

* â€œWhen itâ€™s done, Iâ€™ll **call back** the function you gave me.â€

Thatâ€™s how we achieve **non-blocking, delayed execution**.

Example with 

```
console.log("Start");

setTimeout(() => {
  console.log("This runs later!");
}, 2000);

console.log("End");
```

Output:

```
Start
End
This runs later!
```

Notice how the callback inside `setTimeout` only runs **after 2 seconds** â€” not immediately.

* * *

5. Key Point: Reference vs Execution

------------------------------------

When you pass a function as an argument, youâ€™re passing its **reference**, not its **result**.

By passing the reference, the receiving function gets control over **when** to execute it.

* * *

Final Thoughts
--------------

Callbacks may seem tricky at first, but theyâ€™re just functions passed around like variables. The magic happens because the receiving function can **choose when** to run them â€” immediately, later, or only if certain conditions are met.

Once you really get this idea, youâ€™ll see callbacks everywhere in JavaScript â€” and youâ€™ll understand why theyâ€™re such an important building block for async programming.

* * *
