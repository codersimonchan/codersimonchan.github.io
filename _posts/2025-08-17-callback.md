---
layout: post
title: How Callback Works
tags: [JS]
---

Understanding Callback Functions in JavaScript (Made Simple)
============================================================

When people first hear about **callback functions**, they often get confused. The term sounds fancy, but the concept is actually straightforward once you break it down. Let’s go step by step.

* * *

1. What Is a Callback Function?

-------------------------------

A **callback function** is simply a function that you **pass as an argument** to another function. The receiving function can then **decide when to call (or “call back”) that function**.

👉 Think of it like giving someone your phone number. They’re not calling you right away. Instead, you’re saying:  
_“Here’s my number. Call me back later when you have news.”_

That’s exactly what a callback is in programming:

* You pass a function (your phone number).

* The other function saves it.

* It “calls back” that function at the right time.

* * *

2. Passing Functions as Arguments

---------------------------------

In JavaScript, functions are **first-class citizens**. This means you can treat them like any other variable — you can assign them to variables, pass them around, and use them as arguments.

```
function greet(name) {
  console.log("Hello, " + name);
}

function processUserInput(callback) {
  const name = "Alice";
  callback(name);  // call the function passed in
}

processUserInput(greet);
// Output: Hello, Alice

```

* Here, `greet` is not executed immediately when we pass it to `processUserInput`.

* Instead, its **reference** is passed (basically, the memory address where the function lives).

* Later, inside `processUserInput`, the function gets invoked with `callback(name)`.

* * *

3. Regular Functions vs Callback Functions

------------------------------------------

You can think about it like this:

* **Regular function** → Takes data as input and always applies the _same method_ to process it.

* **Callback function** → Lets you change the _method itself_. You’re basically passing an _algorithm_ (a function) into another function, so the same data can be processed in different ways.

Example:

```
function processNumbers(numbers, callback) {
  return numbers.map(callback);
}

const numbers = [1, 2, 3];

// Double each number
console.log(processNumbers(numbers, num => num * 2));
// [2, 4, 6]

// Square each number
console.log(processNumbers(numbers, num => num * num));
// [1, 4, 9]

```

Here, the same data (`numbers`) is processed differently depending on which callback you provide.

* * *

4. Why Do We Need Callbacks?

----------------------------

The **real power** of callbacks comes with **asynchronous operations**.

JavaScript is single-threaded — it can’t do everything at once. But things like:

* Reading a file,

* Making a network request,

* Querying a database,

all take time. If the program paused and waited for these to finish, everything would freeze!

Instead, JavaScript says:

* “I’ll start this operation.”

* “When it’s done, I’ll **call back** the function you gave me.”

That’s how we achieve **non-blocking, delayed execution**.

Example with 

```
console.log("Start");

setTimeout(() => {
  console.log("This runs later!");
}, 2000);

console.log("End");
```

Output:

```
Start
End
This runs later!
```

Notice how the callback inside `setTimeout` only runs **after 2 seconds** — not immediately.

* * *

5. Key Point: Reference vs Execution

------------------------------------

When you pass a function as an argument, you’re passing its **reference**, not its **result**.

By passing the reference, the receiving function gets control over **when** to execute it.

* * *

Final Thoughts
--------------

Callbacks may seem tricky at first, but they’re just functions passed around like variables. The magic happens because the receiving function can **choose when** to run them — immediately, later, or only if certain conditions are met.

Once you really get this idea, you’ll see callbacks everywhere in JavaScript — and you’ll understand why they’re such an important building block for async programming.

* * *
